#!/usr/bin/env python3
"""
ğŸ“Š å®Œå…¨ä¿®æ­£ç‰ˆ ThreadsæŠ•ç¨¿ç®¡ç†ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰
"""

import streamlit as st
import sqlite3
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime, timedelta, date
import json
import os
from typing import List, Dict, Any

# ãƒšãƒ¼ã‚¸è¨­å®š
st.set_page_config(
    page_title="ThreadsæŠ•ç¨¿ç®¡ç†ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰",
    page_icon="ğŸ“±",
    layout="wide",
    initial_sidebar_state="expanded"
)

class FixedThreadsDashboard:
    """ğŸ“Š ä¿®æ­£ç‰ˆThreadsãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰"""
    
    def __init__(self):
        # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­å®šã‚’å®Ÿéš›ã®ãƒ†ãƒ¼ãƒ–ãƒ«åã«åˆã‚ã›ã¦ä¿®æ­£
        self.db_configs = {
            "scheduled_posts.db": "scheduled_posts",
            "threads_optimized.db": "threads_posts",
            "buzz_history.db": "buzz_history", 
            "viral_history.db": "post_history"
        }
    
    def get_all_posts(self) -> pd.DataFrame:
        """å…¨æŠ•ç¨¿ãƒ‡ãƒ¼ã‚¿å–å¾—"""
        all_posts = []
        
        for db_path, table_name in self.db_configs.items():
            if not os.path.exists(db_path):
                st.info(f"ğŸ“‚ {db_path} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼ˆæœªç”Ÿæˆã®å ´åˆã¯æ­£å¸¸ã§ã™ï¼‰")
                continue
                
            try:
                posts_df = self._get_posts_from_db(db_path, table_name)
                if not posts_df.empty:
                    posts_df['source'] = db_path.replace('.db', '')
                    all_posts.append(posts_df)
                    st.success(f"âœ… {db_path}: {len(posts_df)}ä»¶èª­ã¿è¾¼ã¿")
                    
            except Exception as e:
                st.error(f"âŒ {db_path} ã‚¨ãƒ©ãƒ¼: {e}")
                continue
        
        if all_posts:
            combined_df = pd.concat(all_posts, ignore_index=True, sort=False)
            combined_df = self._clean_dataframe(combined_df)
            return combined_df
        else:
            return pd.DataFrame()
    
    def _get_posts_from_db(self, db_path: str, table_name: str) -> pd.DataFrame:
        """ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰æŠ•ç¨¿å–å¾—"""
        conn = sqlite3.connect(db_path)
        
        try:
            # ãƒ†ãƒ¼ãƒ–ãƒ«å­˜åœ¨ç¢ºèª
            cursor = conn.cursor()
            cursor.execute(
                "SELECT name FROM sqlite_master WHERE type='table' AND name=?",
                (table_name,)
            )
            
            if not cursor.fetchone():
                return pd.DataFrame()
            
            # ã‚«ãƒ©ãƒ æƒ…å ±å–å¾—
            cursor.execute(f"PRAGMA table_info({table_name})")
            columns_info = cursor.fetchall()
            available_columns = [col[1] for col in columns_info]
            
            # åŸºæœ¬ã‚¯ã‚¨ãƒªæ§‹ç¯‰
            select_columns = ['id', 'content']
            
            # åˆ©ç”¨å¯èƒ½ãªã‚«ãƒ©ãƒ ã‚’è¿½åŠ 
            optional_columns = {
                'scheduled_time': 'scheduled_time',
                'generated_at': 'scheduled_time', 
                'created_at': 'scheduled_time',
                'status': 'status',
                'pattern_type': 'pattern_type',
                'engagement_score': 'engagement_prediction',
                'engagement_prediction': 'engagement_prediction',
                'actual_engagement': 'actual_engagement',
                'clicks': 'clicks',
                'shares': 'shares', 
                'comments': 'comments',
                'likes': 'likes',
                'hashtags': 'hashtags',
                'hashtag': 'hashtags'
            }
            
            for col_name, target_name in optional_columns.items():
                if col_name in available_columns and target_name not in [c.split(' as ')[-1] for c in select_columns]:
                    if col_name == target_name:
                        select_columns.append(col_name)
                    else:
                        select_columns.append(f"{col_name} as {target_name}")
            
            # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ä»˜ãã‚«ãƒ©ãƒ è¿½åŠ 
            defaults = {
                'clicks': 0,
                'shares': 0,
                'comments': 0, 
                'likes': 0,
                'actual_engagement': 0.0,
                'engagement_prediction': 0.0
            }
            
            for col_name, default_val in defaults.items():
                if col_name not in [c.split(' as ')[-1] for c in select_columns]:
                    select_columns.append(f"{default_val} as {col_name}")
            
            query = f"""
            SELECT {', '.join(select_columns)}
            FROM {table_name}
            ORDER BY CASE 
                WHEN scheduled_time IS NOT NULL THEN scheduled_time
                WHEN generated_at IS NOT NULL THEN generated_at  
                WHEN created_at IS NOT NULL THEN created_at
                ELSE datetime('now')
            END DESC
            LIMIT 100
            """
            
            df = pd.read_sql_query(query, conn)
            return df
            
        finally:
            conn.close()
    
    def _clean_dataframe(self, df: pd.DataFrame) -> pd.DataFrame:
        """ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ¬ãƒ¼ãƒ ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°"""
        # æ™‚é–“ã‚«ãƒ©ãƒ å¤‰æ›
        if 'scheduled_time' in df.columns:
            df['scheduled_time'] = pd.to_datetime(df['scheduled_time'], errors='coerce')
        
        # æ•°å€¤ã‚«ãƒ©ãƒ ã®å‡¦ç†
        numeric_columns = ['engagement_prediction', 'actual_engagement', 'clicks', 'shares', 'comments', 'likes']
        for col in numeric_columns:
            if col in df.columns:
                df[col] = pd.to_numeric(df[col], errors='coerce').fillna(0)
        
        # æ–‡å­—åˆ—ã‚«ãƒ©ãƒ ã®å‡¦ç†
        string_columns = ['status', 'pattern_type', 'hashtags']
        for col in string_columns:
            if col in df.columns:
                df[col] = df[col].fillna('N/A')
        
        return df

def main():
    """ãƒ¡ã‚¤ãƒ³ç”»é¢"""
    st.title("ğŸ“± ThreadsæŠ•ç¨¿ç®¡ç†ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰")
    st.markdown("### å®Œå…¨ä¿®æ­£ç‰ˆãƒ»ã‚¨ãƒ©ãƒ¼è§£æ¶ˆ")
    
    # ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰åˆæœŸåŒ–
    dashboard = FixedThreadsDashboard()
    
    # ãƒ‡ãƒ¼ã‚¿å–å¾—
    with st.spinner("ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ä¸­..."):
        df = dashboard.get_all_posts()
    
    # ãƒ‡ãƒ¼ã‚¿è¡¨ç¤º
    if not df.empty:
        st.success(f"ğŸ‰ {len(df)}ä»¶ã®æŠ•ç¨¿ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ")
        
        # åŸºæœ¬çµ±è¨ˆ
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric("ç·æŠ•ç¨¿æ•°", f"{len(df):,}")
        
        with col2:
            avg_engagement = df['actual_engagement'].mean()
            st.metric("å¹³å‡ã‚¨ãƒ³ã‚²ãƒ¼ã‚¸ãƒ¡ãƒ³ãƒˆ", f"{avg_engagement:.1f}")
        
        with col3:
            total_likes = int(df['likes'].sum())
            st.metric("ç·ã„ã„ã­", f"{total_likes:,}")
        
        with col4:
            total_clicks = int(df['clicks'].sum())  
            st.metric("ç·ã‚¯ãƒªãƒƒã‚¯", f"{total_clicks:,}")
        
        # ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹å†…è¨³
        if 'source' in df.columns:
            st.subheader("ğŸ“Š ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹åˆ¥å†…è¨³")
            source_counts = df['source'].value_counts()
            
            fig = px.pie(
                values=source_counts.values,
                names=source_counts.index,
                title="æŠ•ç¨¿ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹åˆ†å¸ƒ"
            )
            st.plotly_chart(fig, use_container_width=True)
        
        # æœ€æ–°æŠ•ç¨¿ä¸€è¦§
        st.subheader("ğŸ“ æœ€æ–°æŠ•ç¨¿")
        
        # è¡¨ç¤ºä»¶æ•°é¸æŠ
        display_count = st.selectbox("è¡¨ç¤ºä»¶æ•°", [5, 10, 20, 50], index=0)
        
        recent_posts = df.head(display_count)
        
        for idx, post in recent_posts.iterrows():
            scheduled_time = post.get('scheduled_time')
            time_str = scheduled_time.strftime('%m/%d %H:%M') if pd.notna(scheduled_time) else 'N/A'
            
            pattern = post.get('pattern_type', 'N/A')
            source = post.get('source', 'N/A')
            status = post.get('status', 'N/A')
            
            with st.expander(f"{time_str} - {pattern} ({source}) [{status}]"):
                content = post.get('content', '')
                display_content = content[:200] + "..." if len(content) > 200 else content
                st.write(display_content)
                
                col1, col2, col3, col4 = st.columns(4)
                with col1:
                    st.metric("ğŸ‘ ã„ã„ã­", int(post.get('likes', 0)))
                with col2:
                    st.metric("ğŸ”— ã‚¯ãƒªãƒƒã‚¯", int(post.get('clicks', 0)))
                with col3:
                    st.metric("ğŸ’¬ ã‚³ãƒ¡ãƒ³ãƒˆ", int(post.get('comments', 0)))
                with col4:
                    st.metric("ğŸ“Š ã‚¨ãƒ³ã‚²ãƒ¼ã‚¸ãƒ¡ãƒ³ãƒˆ", f"{post.get('actual_engagement', 0):.1f}")
        
        # è©³ç´°ãƒ‡ãƒ¼ã‚¿ãƒ†ãƒ¼ãƒ–ãƒ«
        if st.checkbox("è©³ç´°ãƒ‡ãƒ¼ã‚¿ãƒ†ãƒ¼ãƒ–ãƒ«è¡¨ç¤º"):
            st.subheader("ğŸ” å…¨ãƒ‡ãƒ¼ã‚¿ãƒ†ãƒ¼ãƒ–ãƒ«")
            st.dataframe(df, use_container_width=True)
    
    else:
        st.warning("ğŸ“­ æŠ•ç¨¿ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“")
        
        st.markdown("""
        ### ğŸš€ æŠ•ç¨¿ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆã™ã‚‹ã«ã¯:
        
        **1. æŠ•ç¨¿ç”Ÿæˆ**
        ```bash
        THREADS_ULTIMATE_START.bat
        ```
        
        **2. æŠ•ç¨¿å®Ÿè¡Œ** 
        ```bash
        BUZZ_SETUP.bat
        ```
        
        **3. ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰æ›´æ–°**
        - ã“ã®ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ï¼ˆF5ï¼‰
        """)
        
        if st.button("ğŸ”„ ä»Šã™ããƒ‡ãƒ¼ã‚¿ã‚’å†èª­ã¿è¾¼ã¿"):
            st.rerun()

if __name__ == "__main__":
    main()