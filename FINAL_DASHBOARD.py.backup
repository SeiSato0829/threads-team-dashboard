#!/usr/bin/env python3
"""
ğŸ“Š æœ€çµ‚ç‰ˆ ThreadsæŠ•ç¨¿ç®¡ç†ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰
ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å•é¡Œå®Œå…¨è§£æ±ºç‰ˆ
"""

import streamlit as st
import sqlite3
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime, timedelta, date
import json
import os
from typing import List, Dict, Any

# ãƒšãƒ¼ã‚¸è¨­å®š
st.set_page_config(
    page_title="ThreadsæŠ•ç¨¿ç®¡ç†ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰",
    page_icon="ğŸ“±",
    layout="wide",
    initial_sidebar_state="expanded"
)

class FinalThreadsDashboard:
    """ğŸ“Š æœ€çµ‚ç‰ˆThreadsãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰"""
    
    def __init__(self):
        self.db_configs = {
            "scheduled_posts.db": {
                "table": "scheduled_posts",
                "alias": "scheduled_posts"
            },
            "threads_optimized.db": {
                "table": "threads_posts", 
                "alias": "threads_optimized"
            },
            "buzz_history.db": {
                "table": "buzz_history",
                "alias": "buzz_history"
            },
            "viral_history.db": {
                "table": "post_history",
                "alias": "viral_history"
            }
        }
    
    def get_all_posts(self) -> pd.DataFrame:
        """å…¨æŠ•ç¨¿ãƒ‡ãƒ¼ã‚¿å–å¾—ï¼ˆå®Œå…¨ç‰ˆï¼‰"""
        all_posts = []
        
        for db_path, config in self.db_configs.items():
            if not os.path.exists(db_path):
                continue
                
            try:
                posts_df = self._get_posts_from_db(db_path, config)
                if not posts_df.empty:
                    posts_df['source'] = config['alias']
                    all_posts.append(posts_df)
                    
            except Exception as e:
                st.warning(f"ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹èª­ã¿è¾¼ã¿è­¦å‘Š ({db_path}): {e}")
                continue
        
        if all_posts:
            combined_df = pd.concat(all_posts, ignore_index=True, sort=False)
            combined_df = self._clean_dataframe(combined_df)
            return combined_df
        else:
            return pd.DataFrame()
    
    def _get_posts_from_db(self, db_path: str, config: Dict) -> pd.DataFrame:
        """å€‹åˆ¥ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰æŠ•ç¨¿å–å¾—"""
        conn = sqlite3.connect(db_path)
        
        try:
            # ãƒ†ãƒ¼ãƒ–ãƒ«å­˜åœ¨ç¢ºèª
            cursor = conn.cursor()
            cursor.execute(
                "SELECT name FROM sqlite_master WHERE type='table' AND name=?",
                (config['table'],)
            )
            
            if not cursor.fetchone():
                return pd.DataFrame()
            
            # ã‚«ãƒ©ãƒ æƒ…å ±å–å¾—
            columns_df = pd.read_sql_query(f"PRAGMA table_info({config['table']})", conn)
            available_columns = columns_df['name'].tolist()
            
            # æ¨™æº–åŒ–ã•ã‚ŒãŸã‚¯ã‚¨ãƒªæ§‹ç¯‰
            query = self._build_standardized_query(config['table'], available_columns)
            
            df = pd.read_sql_query(query, conn)
            return df
            
        finally:
            conn.close()
    
    def _build_standardized_query(self, table_name: str, available_columns: List[str]) -> str:
        """æ¨™æº–åŒ–ã•ã‚ŒãŸã‚¯ã‚¨ãƒªæ§‹ç¯‰"""
        
        # ãƒ‡ãƒãƒƒã‚°ç”¨ãƒ­ã‚°å‡ºåŠ›
        print(f"DEBUG: Building query for table {table_name}")
        print(f"DEBUG: Available columns: {available_columns}")
        
        # å¿…é ˆã‚«ãƒ©ãƒ 
        select_parts = ['id', 'content']
        
        # ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚«ãƒ©ãƒ ã®ãƒãƒƒãƒ”ãƒ³ã‚°
        column_mapping = {
            'scheduled_time': ['scheduled_time', 'generated_at', 'created_at'],
            'status': ['status'],
            'engagement_prediction': ['engagement_prediction', 'engagement_score'],
            'actual_engagement': ['actual_engagement'],
            'clicks': ['clicks'],
            'shares': ['shares'],
            'comments': ['comments'],
            'likes': ['likes'],
            'pattern_type': ['pattern_type'],
            'hashtags': ['hashtags', 'hashtag'],
            'posted_at': ['posted_at'],
            'error_message': ['error_message'],
            'retry_count': ['retry_count'],
            'content_type': ['content_type'],
            'theme': ['theme'],
            'emotion': ['emotion'],
            'template_id': ['template_id']
        }
        
        # ã‚«ãƒ©ãƒ ãƒãƒƒãƒ”ãƒ³ã‚°ã«åŸºã¥ã„ã¦SELECTæ–‡æ§‹ç¯‰
        for target_column, possible_columns in column_mapping.items():
            found_column = None
            for possible in possible_columns:
                if possible in available_columns:
                    found_column = possible
                    break
            
            if found_column:
                if found_column != target_column:
                    select_parts.append(f"{found_column} as {target_column}")
                else:
                    select_parts.append(target_column)
            else:
                # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
                if target_column in ['clicks', 'shares', 'comments', 'likes', 'retry_count']:
                    select_parts.append(f"0 as {target_column}")
                elif target_column in ['engagement_prediction', 'actual_engagement']:
                    select_parts.append(f"0.0 as {target_column}")
                else:
                    select_parts.append(f"NULL as {target_column}")
        
        query = f"""
        SELECT {', '.join(select_parts)}
        FROM {table_name}
        ORDER BY COALESCE(
            {self._find_time_column(available_columns)}, 
            datetime('now')
        ) DESC
        LIMIT 200
        """
        
        return query
    
    def _find_time_column(self, available_columns: List[str]) -> str:
        """æ™‚é–“ã‚«ãƒ©ãƒ ã‚’ç‰¹å®š"""
        time_columns = ['scheduled_time', 'generated_at', 'created_at', 'posted_at']
        
        for col in time_columns:
            if col in available_columns:
                return col
        
        return "datetime('now')"
    
    def _clean_dataframe(self, df: pd.DataFrame) -> pd.DataFrame:
        """ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ¬ãƒ¼ãƒ ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°"""
        # æ™‚é–“ã‚«ãƒ©ãƒ å¤‰æ›
        if 'scheduled_time' in df.columns:
            df['scheduled_time'] = pd.to_datetime(df['scheduled_time'], errors='coerce')
        
        # æ•°å€¤ã‚«ãƒ©ãƒ ã®å‹å¤‰æ›ã¨NaNå‡¦ç†
        numeric_columns = ['engagement_prediction', 'actual_engagement', 'clicks', 'shares', 'comments', 'likes', 'retry_count']
        
        for col in numeric_columns:
            if col in df.columns:
                df[col] = pd.to_numeric(df[col], errors='coerce').fillna(0)
        
        # æ–‡å­—åˆ—ã‚«ãƒ©ãƒ ã®NaNå‡¦ç†
        string_columns = ['status', 'pattern_type', 'hashtags', 'content_type', 'error_message']
        
        for col in string_columns:
            if col in df.columns:
                df[col] = df[col].fillna('N/A')
        
        return df
    
    def get_performance_stats(self, df: pd.DataFrame) -> Dict[str, Any]:
        """ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹çµ±è¨ˆè¨ˆç®—"""
        if df.empty:
            return self._empty_stats()
        
        total_posts = len(df)
        posted_count = len(df[df.get('status', '') == 'posted'])
        pending_count = len(df[df.get('status', '') == 'pending'])
        failed_count = len(df[df.get('status', '') == 'failed'])
        
        # æ•°å€¤çµ±è¨ˆ
        avg_engagement = df['actual_engagement'].mean()
        avg_prediction = df['engagement_prediction'].mean()
        
        total_clicks = int(df['clicks'].sum())
        total_shares = int(df['shares'].sum())
        total_comments = int(df['comments'].sum())
        total_likes = int(df['likes'].sum())
        
        # æ—¥åˆ¥çµ±è¨ˆ
        daily_stats = self._calculate_daily_stats(df)
        
        # ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ¥çµ±è¨ˆ
        pattern_stats = self._calculate_pattern_stats(df)
        
        return {
            'total_posts': total_posts,
            'posted_count': posted_count,
            'pending_count': pending_count,
            'failed_count': failed_count,
            'avg_engagement': avg_engagement,
            'avg_prediction': avg_prediction,
            'total_clicks': total_clicks,
            'total_shares': total_shares,
            'total_comments': total_comments,
            'total_likes': total_likes,
            'daily_stats': daily_stats,
            'pattern_stats': pattern_stats
        }
    
    def _empty_stats(self) -> Dict[str, Any]:
        """ç©ºã®çµ±è¨ˆ"""
        return {
            'total_posts': 0,
            'posted_count': 0,
            'pending_count': 0,
            'failed_count': 0,
            'avg_engagement': 0,
            'avg_prediction': 0,
            'total_clicks': 0,
            'total_shares': 0,
            'total_comments': 0,
            'total_likes': 0,
            'daily_stats': pd.DataFrame(),
            'pattern_stats': pd.DataFrame()
        }
    
    def _calculate_daily_stats(self, df: pd.DataFrame) -> pd.DataFrame:
        """æ—¥åˆ¥çµ±è¨ˆè¨ˆç®—"""
        if 'scheduled_time' not in df.columns or df['scheduled_time'].isna().all():
            return pd.DataFrame()
        
        df_with_date = df.copy()
        df_with_date['date'] = df_with_date['scheduled_time'].dt.date
        
        daily_stats = df_with_date.groupby('date').agg({
            'clicks': 'sum',
            'shares': 'sum',
            'comments': 'sum',
            'likes': 'sum',
            'actual_engagement': 'mean',
            'id': 'count'
        }).rename(columns={'id': 'post_count'}).reset_index()
        
        return daily_stats
    
    def _calculate_pattern_stats(self, df: pd.DataFrame) -> pd.DataFrame:
        """ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ¥çµ±è¨ˆè¨ˆç®—"""
        if 'pattern_type' not in df.columns or df['pattern_type'].isna().all():
            return pd.DataFrame()
        
        pattern_stats = df.groupby('pattern_type').agg({
            'actual_engagement': 'mean',
            'engagement_prediction': 'mean',
            'clicks': 'sum',
            'likes': 'sum',
            'shares': 'sum',
            'id': 'count'
        }).rename(columns={'id': 'post_count'}).reset_index()
        
        return pattern_stats

def main():
    """ãƒ¡ã‚¤ãƒ³ç”»é¢"""
    st.title("ğŸ“± ThreadsæŠ•ç¨¿ç®¡ç†ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰")
    st.markdown("### æœ€çµ‚ç‰ˆãƒ»å®Œå…¨å‹•ä½œä¿è¨¼")
    
    # ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰åˆæœŸåŒ–
    dashboard = FinalThreadsDashboard()
    
    # ãƒ‡ãƒ¼ã‚¿å–å¾—
    with st.spinner("ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ä¸­..."):
        df = dashboard.get_all_posts()
        stats = dashboard.get_performance_stats(df)
    
    # ãƒ‡ãƒ¼ã‚¿çŠ¶æ³è¡¨ç¤º
    if not df.empty:
        st.success(f"âœ… {len(df)}ä»¶ã®æŠ•ç¨¿ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ")
        
        # ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹å†…è¨³
        if 'source' in df.columns:
            source_counts = df['source'].value_counts()
            cols = st.columns(len(source_counts))
            
            for i, (source, count) in enumerate(source_counts.items()):
                with cols[i]:
                    st.metric(f"ğŸ“Š {source}", f"{count}ä»¶")
    
    else:
        st.error("ğŸ“­ æŠ•ç¨¿ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“")
        
        st.markdown("""
        ### ğŸš€ æŠ•ç¨¿ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆã™ã‚‹ã«ã¯:
        
        **1. æŠ•ç¨¿ç”Ÿæˆ**
        ```bash
        THREADS_ULTIMATE_START.bat
        ```
        
        **2. æŠ•ç¨¿å®Ÿè¡Œ** 
        ```bash
        BUZZ_SETUP.bat
        ```
        
        **3. ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰æ›´æ–°**
        - ã“ã®ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ï¼ˆF5ï¼‰
        """)
        
        if st.button("ğŸ”„ ä»Šã™ããƒ‡ãƒ¼ã‚¿ã‚’å†èª­ã¿è¾¼ã¿"):
            st.rerun()
        
        return
    
    # ã‚µã‚¤ãƒ‰ãƒãƒ¼ãƒ¡ãƒ‹ãƒ¥ãƒ¼
    st.sidebar.title("ğŸ“Š ãƒ¡ãƒ‹ãƒ¥ãƒ¼")
    page = st.sidebar.selectbox(
        "è¡¨ç¤ºå†…å®¹ã‚’é¸æŠ",
        ["ğŸ“ˆ æ¦‚è¦ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰", "ğŸ“ æŠ•ç¨¿å±¥æ­´", "ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åˆ†æ", "ğŸ”§ ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ³"]
    )
    
    # ãƒšãƒ¼ã‚¸è¡¨ç¤º
    if page == "ğŸ“ˆ æ¦‚è¦ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰":
        show_overview_dashboard(df, stats)
    elif page == "ğŸ“ æŠ•ç¨¿å±¥æ­´":
        show_post_history(df)
    elif page == "ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åˆ†æ":
        show_performance_analysis(df, stats)
    elif page == "ğŸ”§ ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ³":
        show_system_status(dashboard)

def show_overview_dashboard(df: pd.DataFrame, stats: Dict):
    """æ¦‚è¦ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰è¡¨ç¤º"""
    st.header("ğŸ“ˆ æŠ•ç¨¿ç®¡ç†æ¦‚è¦")
    
    # KPIã‚«ãƒ¼ãƒ‰
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric(
            "ç·æŠ•ç¨¿æ•°",
            f"{stats['total_posts']:,}",
            delta=f"æŠ•ç¨¿æ¸ˆã¿: {stats['posted_count']}"
        )
    
    with col2:
        st.metric(
            "å¹³å‡ã‚¨ãƒ³ã‚²ãƒ¼ã‚¸ãƒ¡ãƒ³ãƒˆ",
            f"{stats['avg_engagement']:.1f}",
            delta=f"äºˆæ¸¬: {stats['avg_prediction']:.1f}"
        )
    
    with col3:
        st.metric(
            "ç·åå¿œæ•°",
            f"{stats['total_likes'] + stats['total_shares'] + stats['total_comments']:,}",
            delta=f"ã‚¯ãƒªãƒƒã‚¯: {stats['total_clicks']}"
        )
    
    with col4:
        completion_rate = (stats['posted_count'] / stats['total_posts'] * 100) if stats['total_posts'] > 0 else 0
        st.metric(
            "æŠ•ç¨¿å®Œäº†ç‡",
            f"{completion_rate:.1f}%",
            delta=f"äºˆå®š: {stats['pending_count']}"
        )
    
    # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹åˆ†å¸ƒ
    st.subheader("ğŸ“Š æŠ•ç¨¿ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹åˆ†å¸ƒ")
    
    status_data = {
        'æŠ•ç¨¿æ¸ˆã¿': stats['posted_count'],
        'äºˆå®š': stats['pending_count'],
        'å¤±æ•—': stats['failed_count'],
        'ãã®ä»–': stats['total_posts'] - stats['posted_count'] - stats['pending_count'] - stats['failed_count']
    }
    
    # 0ä»¥å¤–ã®å€¤ã®ã¿è¡¨ç¤º
    status_data = {k: v for k, v in status_data.items() if v > 0}
    
    if status_data:
        fig = px.pie(
            values=list(status_data.values()),
            names=list(status_data.keys()),
            title="æŠ•ç¨¿ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹åˆ†å¸ƒ"
        )
        st.plotly_chart(fig, use_container_width=True)
    
    # æ—¥åˆ¥çµ±è¨ˆã‚°ãƒ©ãƒ•
    if not stats['daily_stats'].empty:
        st.subheader("ğŸ“Š æ—¥åˆ¥ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹")
        
        daily_df = stats['daily_stats']
        
        fig = go.Figure()
        
        fig.add_trace(go.Scatter(
            x=daily_df['date'],
            y=daily_df['post_count'],
            name='æŠ•ç¨¿æ•°',
            line=dict(color='blue')
        ))
        
        fig.add_trace(go.Scatter(
            x=daily_df['date'],
            y=daily_df['likes'],
            name='ã„ã„ã­',
            yaxis='y2',
            line=dict(color='red')
        ))
        
        fig.update_layout(
            title="æ—¥åˆ¥æŠ•ç¨¿æ•°ã¨ã„ã„ã­æ•°",
            xaxis_title="æ—¥ä»˜",
            yaxis_title="æŠ•ç¨¿æ•°",
            yaxis2=dict(title="ã„ã„ã­æ•°", overlaying='y', side='right')
        )
        
        st.plotly_chart(fig, use_container_width=True)
    
    # æœ€æ–°æŠ•ç¨¿
    st.subheader("ğŸ“ æœ€æ–°æŠ•ç¨¿")
    
    recent_posts = df.head(5)
    
    for idx, post in recent_posts.iterrows():
        scheduled_time = post.get('scheduled_time')
        time_str = scheduled_time.strftime('%m/%d %H:%M') if pd.notna(scheduled_time) else 'N/A'
        
        pattern = post.get('pattern_type', 'N/A')
        source = post.get('source', 'N/A')
        status = post.get('status', 'N/A')
        
        with st.expander(f"{time_str} - {pattern} ({source}) [{status}]"):
            content = post.get('content', '')
            display_content = content[:300] + "..." if len(content) > 300 else content
            st.write(display_content)
            
            col1, col2, col3, col4 = st.columns(4)
            with col1:
                st.metric("ğŸ‘ ã„ã„ã­", int(post.get('likes', 0)))
            with col2:
                st.metric("ğŸ”— ã‚¯ãƒªãƒƒã‚¯", int(post.get('clicks', 0)))
            with col3:
                st.metric("ğŸ’¬ ã‚³ãƒ¡ãƒ³ãƒˆ", int(post.get('comments', 0)))
            with col4:
                st.metric("ğŸ“Š ã‚¨ãƒ³ã‚²ãƒ¼ã‚¸ãƒ¡ãƒ³ãƒˆ", f"{post.get('actual_engagement', 0):.1f}")

def show_post_history(df: pd.DataFrame):
    """æŠ•ç¨¿å±¥æ­´è¡¨ç¤º"""
    st.header("ğŸ“ æŠ•ç¨¿å±¥æ­´")
    
    # ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼
    col1, col2, col3 = st.columns(3)
    
    with col1:
        source_options = ['å…¨ã¦'] + df['source'].unique().tolist() if 'source' in df.columns else ['å…¨ã¦']
        source_filter = st.selectbox("ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹", source_options)
    
    with col2:
        pattern_options = ['å…¨ã¦'] + df['pattern_type'].dropna().unique().tolist() if 'pattern_type' in df.columns else ['å…¨ã¦']
        pattern_filter = st.selectbox("æŠ•ç¨¿ãƒ‘ã‚¿ãƒ¼ãƒ³", pattern_options)
    
    with col3:
        status_options = ['å…¨ã¦'] + df['status'].dropna().unique().tolist() if 'status' in df.columns else ['å…¨ã¦']
        status_filter = st.selectbox("ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹", status_options)
    
    # ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°é©ç”¨
    filtered_df = df.copy()
    
    if source_filter != 'å…¨ã¦':
        filtered_df = filtered_df[filtered_df['source'] == source_filter]
    
    if pattern_filter != 'å…¨ã¦':
        filtered_df = filtered_df[filtered_df['pattern_type'] == pattern_filter]
    
    if status_filter != 'å…¨ã¦':
        filtered_df = filtered_df[filtered_df['status'] == status_filter]
    
    st.info(f"ğŸ“‹ è¡¨ç¤ºä»¶æ•°: {len(filtered_df)} / {len(df)}")
    
    # æŠ•ç¨¿ä¸€è¦§
    for idx, post in filtered_df.head(20).iterrows():
        scheduled_time = post.get('scheduled_time')
        time_str = scheduled_time.strftime('%Y/%m/%d %H:%M') if pd.notna(scheduled_time) else 'N/A'
        
        pattern = post.get('pattern_type', 'N/A')
        source = post.get('source', 'N/A')
        status = post.get('status', 'N/A')
        
        with st.expander(f"{time_str} - {pattern} ({source}) [{status}]"):
            st.text_area("æŠ•ç¨¿å†…å®¹", post.get('content', ''), height=120, key=f"content_{idx}", disabled=True)
            
            col1, col2, col3 = st.columns(3)
            
            with col1:
                st.write("**ã‚¨ãƒ³ã‚²ãƒ¼ã‚¸ãƒ¡ãƒ³ãƒˆ**")
                st.write(f"ğŸ‘ ã„ã„ã­: {int(post.get('likes', 0))}")
                st.write(f"ğŸ’¬ ã‚³ãƒ¡ãƒ³ãƒˆ: {int(post.get('comments', 0))}")
                st.write(f"ğŸ”— ã‚¯ãƒªãƒƒã‚¯: {int(post.get('clicks', 0))}")
            
            with col2:
                st.write("**çµ±è¨ˆ**")
                st.write(f"ğŸ“Š å®Ÿç¸¾: {post.get('actual_engagement', 0):.1f}")
                st.write(f"ğŸ¯ äºˆæ¸¬: {post.get('engagement_prediction', 0):.1f}")
                st.write(f"ğŸ”„ ãƒªãƒˆãƒ©ã‚¤: {int(post.get('retry_count', 0))}å›")
            
            with col3:
                st.write("**ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿**")
                st.write(f"ğŸ·ï¸ ãƒãƒƒã‚·ãƒ¥ã‚¿ã‚°: {post.get('hashtags', 'N/A')}")
                st.write(f"ğŸ­ ãƒ‘ã‚¿ãƒ¼ãƒ³: {pattern}")
                st.write(f"ğŸ“± ã‚½ãƒ¼ã‚¹: {source}")

def show_performance_analysis(df: pd.DataFrame, stats: Dict):
    """ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åˆ†æè¡¨ç¤º"""
    st.header("ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åˆ†æ")
    
    # ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ¥åˆ†æ
    if not stats['pattern_stats'].empty:
        st.subheader("ğŸ¯ ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ¥ã‚¨ãƒ³ã‚²ãƒ¼ã‚¸ãƒ¡ãƒ³ãƒˆ")
        
        pattern_df = stats['pattern_stats']
        
        fig = px.bar(
            pattern_df,
            x='pattern_type',
            y='actual_engagement',
            title="æŠ•ç¨¿ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ¥å¹³å‡ã‚¨ãƒ³ã‚²ãƒ¼ã‚¸ãƒ¡ãƒ³ãƒˆ"
        )
        st.plotly_chart(fig, use_container_width=True)
        
        # ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ¥è©³ç´°çµ±è¨ˆ
        st.dataframe(pattern_df)
    
    # æ™‚é–“å¸¯åˆ¥åˆ†æ
    if 'scheduled_time' in df.columns and not df['scheduled_time'].isna().all():
        st.subheader("â° æ™‚é–“å¸¯åˆ¥åˆ†æ")
        
        df_time = df.copy()
        df_time['hour'] = df_time['scheduled_time'].dt.hour
        
        hourly_stats = df_time.groupby('hour').agg({
            'actual_engagement': 'mean',
            'clicks': 'sum',
            'likes': 'sum'
        }).reset_index()
        
        fig = go.Figure()
        
        fig.add_trace(go.Scatter(
            x=hourly_stats['hour'],
            y=hourly_stats['actual_engagement'],
            name='å¹³å‡ã‚¨ãƒ³ã‚²ãƒ¼ã‚¸ãƒ¡ãƒ³ãƒˆ',
            line=dict(color='blue')
        ))
        
        fig.add_trace(go.Scatter(
            x=hourly_stats['hour'],
            y=hourly_stats['likes'],
            name='ã„ã„ã­æ•°',
            yaxis='y2',
            line=dict(color='red')
        ))
        
        fig.update_layout(
            title="æ™‚é–“å¸¯åˆ¥ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹",
            xaxis_title="æ™‚é–“",
            yaxis_title="ã‚¨ãƒ³ã‚²ãƒ¼ã‚¸ãƒ¡ãƒ³ãƒˆ",
            yaxis2=dict(title="ã„ã„ã­æ•°", overlaying='y', side='right')
        )
        
        st.plotly_chart(fig, use_container_width=True)
    
    # åŸºæœ¬çµ±è¨ˆ
    st.subheader("ğŸ“Š åŸºæœ¬çµ±è¨ˆã‚µãƒãƒªãƒ¼")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.json({
            "ç·æŠ•ç¨¿æ•°": stats['total_posts'],
            "æŠ•ç¨¿æ¸ˆã¿": stats['posted_count'],
            "äºˆå®š": stats['pending_count'],
            "å¤±æ•—": stats['failed_count']
        })
    
    with col2:
        st.json({
            "å¹³å‡ã‚¨ãƒ³ã‚²ãƒ¼ã‚¸ãƒ¡ãƒ³ãƒˆ": round(stats['avg_engagement'], 2),
            "ç·ã„ã„ã­": stats['total_likes'],
            "ç·ã‚¯ãƒªãƒƒã‚¯": stats['total_clicks'],
            "ç·ã‚³ãƒ¡ãƒ³ãƒˆ": stats['total_comments']
        })

def show_system_status(dashboard: FinalThreadsDashboard):
    """ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ³è¡¨ç¤º"""
    st.header("ğŸ”§ ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ³")
    
    st.subheader("ğŸ’¾ ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹çŠ¶æ³")
    
    for db_path, config in dashboard.db_configs.items():
        st.write(f"**{db_path}**")
        
        if os.path.exists(db_path):
            try:
                conn = sqlite3.connect(db_path)
                
                # ãƒ†ãƒ¼ãƒ–ãƒ«ä¸€è¦§
                tables_df = pd.read_sql_query(
                    "SELECT name FROM sqlite_master WHERE type='table'",
                    conn
                )
                
                st.success(f"âœ… æ¥ç¶šOK - ãƒ†ãƒ¼ãƒ–ãƒ«: {list(tables_df['name'])}")
                
                # ãƒ¬ã‚³ãƒ¼ãƒ‰æ•°ç¢ºèª
                if config['table'] in tables_df['name'].values:
                    count_df = pd.read_sql_query(f"SELECT COUNT(*) as count FROM {config['table']}", conn)
                    st.info(f"ğŸ“Š {config['table']}: {count_df['count'].iloc[0]}ä»¶")
                else:
                    st.warning(f"âš ï¸ ãƒ†ãƒ¼ãƒ–ãƒ« {config['table']} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                
                conn.close()
                
            except Exception as e:
                st.error(f"âŒ ã‚¨ãƒ©ãƒ¼: {e}")
        else:
            st.error(f"âŒ ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ã¾ã›ã‚“")
    
    # ã‚·ã‚¹ãƒ†ãƒ æ¨å¥¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
    st.subheader("ğŸš€ æ¨å¥¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³")
    
    st.markdown("""
    ### ğŸ’¡ æŠ•ç¨¿ãƒ‡ãƒ¼ã‚¿ã‚’å¢—ã‚„ã™ã«ã¯:
    
    **1. æ–°è¦æŠ•ç¨¿ç”Ÿæˆ**
    ```bash
    THREADS_ULTIMATE_START.bat
    ```
    
    **2. è‡ªå‹•æŠ•ç¨¿ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—**
    ```bash
    BUZZ_SETUP.bat
    ```
    
    **3. ã‚¨ãƒ³ã‚²ãƒ¼ã‚¸ãƒ¡ãƒ³ãƒˆãƒ‡ãƒ¼ã‚¿æ›´æ–°**
    - æŠ•ç¨¿å±¥æ­´ã‚¿ãƒ–ã§æ‰‹å‹•æ›´æ–°
    - å®Ÿéš›ã®åå¿œæ•°ã‚’å…¥åŠ›
    """)

if __name__ == "__main__":
    main()